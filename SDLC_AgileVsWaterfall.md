SDLC Agile vs Waterfall An Overview

According to Wikipedia, the two primary SDLC Methodologies are 

Agile Development and the Waterfall Model. Agile Methodologies
are all rooted in the "Agile Manifesto" document published in 2001.

 

The primary tenets of Agile Methodologies are:

    Individuals and Interactions over processes and tool
    Working Software over comprehensive documentation
    Customer Collaboration over contract negotiation
    Responding to Change over following a plan

These tenets are essentially in opposition to the practices of the
Waterfall methodology.

 

The most popular Agile Methodology is Scrum. It was introduced by
Japanese authors in a Harvard Business Review Article in the mid 1980s.
It was based on the "rugby" approach of cross-functional industrial
teams to solve problems flexibly and quickly by working and
communicating together across departments and overlapping traditional
phases of product development. They looked at case studies in the
automotive, photocopier and printer industries.

The methodology started to be used by a couple Software Development
companies in the early 90's, and a joint presentation was made by
two companies who had explored the process deeply at the
Object-Oriented Programming, Systems, Languages & Applications '95
(OOPSLA '95) in Austin, Texas.

The essential tenet of Scrum, is that people learn by having direct
experience and making decisions based on that direct experience.
Therefore it uses an iterative, incremental approach of building
working, even if incomplete, solutions into reality to be used for
direct experience.

Scrum puts together the Product Owners, (final users of the product,)
together with a Development Team, (software design and engineers,) and
a Scrum Master, forming a small group of 3 to 9 people who will work in
short sprints of 2 - 4 weeks of bringing functional iterations of a
product into reality which helps everyone to better understand the
nature of the problem to be solved and produce useful solutions. By
iterating through sprints, learning, adapting and adding features,
a useable product is developed that solves the product owners issues.
With functional work products from sprints, product owners get a much
clearer understanding of what it is they are really wanting, and the
Development Team gets efficient feedback on how much they are really
helping people with their solutions. The Scrum masters job is to keep
people focused on defining and implementing specific measurable outcomes
and following Scrum processes to get them done.

Scrum like all Agile methodologies were developed in response to the
traditional Waterfall method used in early engineering and software
development. Waterfall methods are linear and monolithic in leading
from one stage of the SDLC to the next. Early systems and software
projects were created and run by large corporate and government
institutions who could see no other way to develop projects or software
than the rigid hierarchy and steps of Requirements and Analysis definition,
to Design (of solution,) Implementation of that design, (coding and
testing/verification, and finally maintenance of the final product.
These ideas were about reducing risk and cost, by trying to clear,
well defined requirements, which could be used to contain and reduce
costs in later phases of the process.

The Waterfall method took much longer to get to a working product
that could actually be used, and placed a high value on processes
and tools to create documentation that allowed managers to feel in
"control" of their projects, so they could feel they were reducing risk.

The Waterfall method is still used today because it is easy to
comprehend, and feel like the process can be managed, becuase there
are so many explicit work products for each phase, although they
have little value for directly solving the problem that the larger
process is trying to address. Agile methods have all the steps of
the SDLC, but they are used as a part of each sprint, and not
necessarily in the traditional order, with requirements being little
more than functional use cases for user interaction with software.

